\documentclass{article}
\usepackage{amsmath,amssymb,bm}
\usepackage{graphicx}
\usepackage{kotex}

\newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\bra}[1]{\left\langle#1\right|}
\newcommand{\proj}[1]{\ket{#1}\!\bra{#1}}

\title{Three body QEC: Flow}
\author{}
\date{2026년 2월}

\begin{document}
\maketitle

\section{기본 선형대수 설정}
\subsection{힐베르트 공간과 기저}
전체 공간은
\[
\mathcal{H}=(\mathbb{C}^2)^{\otimes 3}
\]
이고 큐비트 순서는 $(q_0,q_1,q_2)$이다.
계산기저 상태를 $\ket{b_0 b_1 b_2}$ ($b_i\in\{0,1\}$)로 쓴다.

\subsection{초기 상태 (\texttt{prepare\_initial\_state})}
코드는 $H_0$ 후 $\mathrm{CX}_{0\to1}$를 적용하므로
\begin{equation}
\ket{\psi_0}
=\ket{\Phi^+}_{01}\ket{0}_2,\qquad
\ket{\Phi^+}_{01}
=\frac{1}{\sqrt{2}}(\ket{00}+\ket{11}).
\end{equation}
밀도행렬 표기로는
\[
\rho_0=\proj{\psi_0}.
\]

\subsection{참고 안정자}
데이터 2큐비트에 대해
\[
S_Z=Z_0Z_1,\qquad S_X=X_0X_1.
\]
\(\ket{\Phi^+}\)는 두 안정자의 $+1$ 고유상태이다.

\section{코어 유니터리와 노이즈 채널}
\subsection{3-체 결합 유니터리 (\texttt{core/hamiltonian.py})}
코어 유니터리는
\begin{equation}
U_{ZZZ}(\theta)=e^{-i\theta Z_0Z_1Z_2}.
\end{equation}
기저 상태 \(\ket{b_0b_1b_2}\)에서
\[
Z_0Z_1Z_2\ket{b_0b_1b_2}
=(-1)^{b_0+b_1+b_2}\ket{b_0b_1b_2}
\]
이므로 위상은 \(\exp(-i\theta(-1)^{b_0+b_1+b_2})\)가 된다.

\subsection{Depolarizing 채널 정의}
\texttt{qiskit\_aer.noise.depolarizing\_error(p,n)} 관례에 맞춰
\[
\mathcal{D}_p^{(n)}(\rho)
=(1-p)\rho+\frac{p}{4^n-1}\sum_{P\in\mathcal{P}_n\setminus\{I\}}P\rho P
\]
로 쓴다. \(\mathcal{P}_n\)은 \(n\)-큐비트 Pauli 문자열 집합이다.

\subsection{게이트 단위 유효 연산자}
코드의 노이즈 모델은 ``명령어 이름 + 큐비트 인덱스(쌍)''에 붙는다.
따라서 게이트 \(G\)에 대한 유효 작용을 \(\mathcal{E}(G)\)로 쓰면:

\paragraph{1Q 게이트}
\begin{equation}
\mathcal{E}(G_q)(\rho)=
\begin{cases}
\mathcal{D}_{p_{1,\mathrm{data}}}^{(1)}(G_q\rho G_q^\dagger), & q\in\{0,1\},\\
\mathcal{D}_{p_{1,\mathrm{anc}}}^{(1)}(G_q\rho G_q^\dagger), & q=2.
\end{cases}
\end{equation}
적용 대상 명령어는
\[
\{u1,u2,u3,rx,ry,rz,x,y,z,h,s,sdg,t,tdg\}.
\]

\paragraph{Idle (\texttt{id})}
\begin{equation}
\mathcal{E}(\mathrm{id}_q)(\rho)=
\begin{cases}
\mathcal{D}_{p_{\mathrm{id,data}}}^{(1)}(\rho), & q\in\{0,1\},\\
\mathcal{D}_{p_{\mathrm{id,anc}}}^{(1)}(\rho), & q=2.
\end{cases}
\end{equation}

\paragraph{2Q 게이트}
등록된 쌍이
\[
\mathcal{P}_{dd}=\{(0,1)\},\qquad
\mathcal{P}_{da}=\{(0,2),(1,2)\}
\]
일 때
\begin{equation}
\mathcal{E}(G_{ab})(\rho)=
\begin{cases}
\mathcal{D}_{p_{2,\mathrm{dd}}}^{(2)}(G_{ab}\rho G_{ab}^\dagger), & (a,b)\in\mathcal{P}_{dd},\\
\mathcal{D}_{p_{2,\mathrm{da}}}^{(2)}(G_{ab}\rho G_{ab}^\dagger), & (a,b)\in\mathcal{P}_{da}.
\end{cases}
\end{equation}
적용 명령어는 \(\{cx,cz\}\)이다.

\paragraph{Readout 오류}
앤실라 측정 비트에 대해
\[
\tilde{s}=s\oplus \eta,\qquad \eta\sim \mathrm{Bernoulli}(p_{\mathrm{ro,anc}}).
\]
즉
\[
\Pr(\tilde{s}=s)=1-p_{\mathrm{ro,anc}},\qquad
\Pr(\tilde{s}=1-s)=p_{\mathrm{ro,anc}}.
\]

\paragraph{중요 구현 메모}
노이즈는 등록된 명령어 이름에만 즉시 붙는다.
즉 \texttt{U\_ZZZ} 자체는 노이즈 모델에 직접 등록돼 있지 않고,
\texttt{id}, \texttt{cx}, \texttt{cz}, 1Q 기본 게이트 쪽에서 노이즈가 반영된다.

\section{사이클 업데이트의 수식적 Flow}
\subsection{사이클 전반부: 코어 + 훅}
\texttt{CoreParams}를
\[
(\theta,T,n_{\mathrm{id,d}},n_{\mathrm{id,a}},n_{\mathrm{ex,d}},n_{\mathrm{ex,a}})
\]
로 쓴다.

사이클 \(k\)에서 측정 전 상태를
\[
\rho_k^{\mathrm{pre}}
\]
라 하면, 코드 순서대로
\begin{align}
\rho_k^{(1)} &= \mathcal{U}_{ZZZ}(\rho_k),\\
\rho_k^{(2)} &= \left(\mathcal{E}(\mathrm{id}_1)\circ\mathcal{E}(\mathrm{id}_0)\right)^{n_{\mathrm{id,d}}}(\rho_k^{(1)}),\\
\rho_k^{(3)} &= \mathcal{E}(\mathrm{id}_2)^{n_{\mathrm{id,a}}}(\rho_k^{(2)}),\\
\rho_k^{(4)} &= \left(\mathcal{E}(\mathrm{id}_1)\circ\mathcal{E}(\mathrm{id}_0)\right)^{n_{\mathrm{ex,d}}}(\rho_k^{(3)}),\\
\rho_k^{(5)} &= \mathcal{E}(\mathrm{id}_2)^{n_{\mathrm{ex,a}}}(\rho_k^{(4)}),\\
\rho_k^{\mathrm{pre}} &= \mathcal{H}_k(\rho_k^{(5)}).
\end{align}
여기서 \(\mathcal{U}_{ZZZ}(\rho)=U_{ZZZ}\rho U_{ZZZ}^\dagger\).

\subsection{mode="decoded" (\texttt{build\_core\_circuit})}
앤실라 \(Z\)-측정 투영자를 \(\Pi_s=\proj{s}\) (\(s\in\{0,1\}\))라 하면
\begin{equation}
p_k(s)=\mathrm{Tr}\!\left[(I_{01}\otimes \Pi_s)\rho_k^{\mathrm{pre}}\right]
\end{equation}
이며 측정 후(정규화 전) 상태는
\[
\sigma_{k,s}=(I_{01}\otimes \Pi_s)\rho_k^{\mathrm{pre}}(I_{01}\otimes \Pi_s).
\]
코드의 \texttt{qc.reset(2)}는 조건 없는 복원 채널로
\[
\mathcal{R}(\sigma)=\proj{0}_2\otimes \mathrm{Tr}_2[\sigma]
\]
로 볼 수 있다. 따라서 다음 사이클 상태는
\begin{equation}
\rho_{k+1}=\sum_{s\in\{0,1\}}\mathcal{R}(\sigma_{k,s}).
\end{equation}
클래식으로 저장되는 syndrome 비트는 readout 오류가 반영된 \(\tilde{s}_k\)이다.

\subsection{mode="state" (\texttt{build\_core\_circuit})}
사이클 내 측정/리셋이 없으므로
\begin{equation}
\rho_{k+1}=\rho_k^{\mathrm{pre}}.
\end{equation}
옵션 \texttt{save\_density=True}일 때 마지막 \(\rho_T\)를 저장한다.

\subsection{\texttt{build\_core\_circuit\_with\_syndrome}}
각 사이클마다 decoded 모드와 같은 앤실라 측정/리셋을 수행하고,
마지막에 데이터 측정
\[
d_0\sim \mathrm{Meas}_Z(q_0),\qquad d_1\sim \mathrm{Meas}_Z(q_1)
\]
를 추가한다.
즉 최종 counts key에는 데이터 비트 + syndrome 비트가 함께 기록된다.

\section{시나리오별 훅 연산의 구체식}
\subsection{S0: \texttt{scenarios/base.py}}
\[
\mathcal{H}_k^{(S0)}=\mathrm{Id}.
\]
즉 코어 업데이트 식 그대로 진행된다.

\subsection{S1: \texttt{scenarios/nonlocal\_buffer.py}}
파라미터를
\[
\Delta=\max(0,\texttt{extra\_anc\_ticks}),\quad
r=\max(1,\texttt{bridge\_strength})
\]
로 두면, enabled일 때
\begin{equation}
\mathcal{H}_k^{(S1)}
=\left(\mathcal{B}_{m}\right)^r\circ \mathcal{E}(\mathrm{id}_2)^\Delta,
\qquad m\in\{zx,xx\}.
\end{equation}
브릿지는
\begin{align}
\mathcal{B}_{zx} &= \mathcal{E}(\mathrm{CZ}_{2\to1})\circ \mathcal{E}(\mathrm{CX}_{0\to2}),\\
\mathcal{B}_{xx} &= \mathcal{E}(\mathrm{CX}_{2\to1})\circ \mathcal{E}(\mathrm{CX}_{0\to2}).
\end{align}
fallback 모드는 \(\mathcal{B}_{xx}\)이다.

또한 보조 함수로
\[
p_{1,\mathrm{anc}}\leftarrow \alpha p_{1,\mathrm{anc}},\qquad
p_{\mathrm{id,anc}}\leftarrow \alpha p_{\mathrm{id,anc}}
\]
스케일링을 제공하지만, 기본 compare 경로에서 자동 호출되지는 않는다.

\subsection{S2: \texttt{scenarios/topo\_minimal.py}}
파라미터:
\[
R=\max(1,\texttt{check\_reps}),\quad
u=\mathbf{1}\{\texttt{uncompute}\},\quad
f=\mathbf{1}\{\texttt{feedback}\},\quad
t\in\{0,1\}.
\]
한 번의 반복 블록을
\begin{equation}
\mathcal{T}_{t}^{(u,f)}
=\left(\mathcal{E}(\mathrm{CX}_{1\to2})\circ\mathcal{E}(\mathrm{CX}_{0\to2})\right)^u
\circ \mathcal{E}(\mathrm{CX}_{2\to t})^f
\circ \mathcal{E}(\mathrm{CX}_{1\to2})
\circ \mathcal{E}(\mathrm{CX}_{0\to2})
\end{equation}
로 두면
\begin{equation}
\mathcal{H}_k^{(S2)}=\left(\mathcal{T}_{t}^{(u,f)}\right)^R.
\end{equation}

인코딩 부분
\[
U_{\mathrm{enc}}=\mathrm{CX}_{0\to2}\mathrm{CX}_{1\to2}
\]
는
\[
U_{\mathrm{enc}}\ket{a,b,0}=\ket{a,b,a\oplus b}
\]
를 만족하므로 앤실라에 \(Z\)-패리티 정보가 기록된다.

\paragraph{코드 프리셋 (\texttt{make\_hooks})}
\begin{align}
\text{S2a: }&R=1,\;u=1,\;f=0,\;t=0,\\
\text{S2b: }&R=1,\;u=1,\;f=1,\;t=0,\\
\text{S2\_log: }&R=1,\;u=0,\;f=0,\;t=0.
\end{align}
\paragraph{단일 오류 수정 가능성.}
데이터 큐비트에 대한 고려되는 오류 집합을 $\mathcal{E}=\{I, X_0, X_1\}$ 이라고 하면,
상태 $\ket{\Phi^+}_{01}$, 에 대해, 패리티 추출 및 고정 목표 수정에 의해 유도된 복구 맵은 다음을 만족한다.
\[
\mathcal{R}\circ \mathcal{E}(\rho_0) = \rho_0,
\qquad \forall E\in\mathcal{E},
\]
측정 및 게이트 노이즈가 없는 경우에 국한된다.


\section{관측량 계산 Flow}
\subsection{State 모드 점수 (\texttt{experiments/compare.py})}
state 경로에서는 \texttt{fidelity\_data\_2q(..., ideal="00")}를 사용한다.
즉 최종 3큐비트 밀도행렬 \(\rho_T\)에서
\[
\rho_{01}=\mathrm{Tr}_2[\rho_T]
\]
를 만들고,
\begin{equation}
F_{\mathrm{state}}
=\langle 00|\rho_{01}|00\rangle
\end{equation}
를 출력한다.
(일반 fidelity 표기에서는 \(F(\rho_{01},\proj{00})\)와 동일)

\subsection{Decoded 모드 점수 (\texttt{utils/logging.py})}
\paragraph{(1) counts key 파싱}
key에서 공백 제거 후 문자열을 \(\mathrm{bits}(k)\)라 하면
\[
d(k)=\mathrm{bits}(k)[0:2],\qquad
s(k)=\mathrm{bits}(k)[2:2+T].
\]

\paragraph{(2) 디코더}
\[
\mathrm{Maj}(b)=
\begin{cases}
1,& \#1(b)>\#0(b),\\
0,& \text{그 외(동률 포함)}.
\end{cases}
\]
Flat:
\[
\hat{c}_{\mathrm{flat}}(k)=\mathrm{Maj}(s(k)).
\]
Block consensus (\(W>0\)):
\[
s(k)\to (B_0,\dots,B_{J-1}),\quad B_j=s_{jW:(j+1)W},
\]
\[
v_j=\mathrm{Maj}(B_j),\qquad
\hat{c}_{\mathrm{block}}(k)=\mathrm{Maj}(v_0\cdots v_{J-1}).
\]
\(W\le0\)이면 flat으로 fallback.

\paragraph{(3) 보정 적용}
코드의 데이터 비트 표기를 \(d=d_1d_0\)라 할 때
\[
C_t(d,\hat{c})=
\begin{cases}
d, & \hat{c}=0,\\
d\oplus e_t, & \hat{c}=1.
\end{cases}
\]
문자열 수준으로는
\[
C_0(d_1d_0,1)=d_1\bar{d}_0,\qquad
C_1(d_1d_0,1)=\bar{d}_1d_0.
\]

\paragraph{(4) 성공확률}
counts에서 key \(k\)의 빈도를 \(n_k\), 총샷을 \(N=\sum_k n_k\),
목표 문자열을 \(d^\star\)라 하면
\begin{equation}
P_{\mathrm{succ}}
=\frac{1}{N}
\sum_k n_k\,
\mathbf{1}\!\left\{C_t\!\left(d(k),\hat{c}(k)\right)=d^\star\right\}.
\end{equation}
기본값은 \(d^\star=\texttt{"00"}\), \(t=\texttt{flip\_target}\).

\subsection{Syndrome 관측 통계 (\texttt{core/metrics.py})}
\[
\text{detection\_rate}
=\Pr(\tilde{s}\neq 0^T)
=\Pr\!\left(\exists j,\;\tilde{s}_j=1\right),
\]
\[
\text{false\_negative}
=\Pr(\tilde{s}=0^T).
\]
\texttt{experiments/compare.py}의 decoded 경로에서는
link injection OFF 실험의 detection\_rate를 FP 지표로 기록한다.

\section{끝까지 연결한 전체 재귀식}
시나리오 \(X\in\{S0,S1,S2\}\), 모드 \(m\in\{\text{state},\text{decoded}\}\)에 대해:
\[
\rho_0=\proj{\psi_0},
\]
\[
\rho_k^{\mathrm{pre}}
=\mathcal{H}_k^{(X)}
\circ\mathcal{I}_{\mathrm{ex,a}}
\circ\mathcal{I}_{\mathrm{ex,d}}
\circ\mathcal{I}_{\mathrm{a}}
\circ\mathcal{I}_{\mathrm{d}}
\circ\mathcal{U}_{ZZZ}(\rho_k),
\]
\[
\rho_{k+1}=
\begin{cases}
\rho_k^{\mathrm{pre}}, & m=\text{state},\\
\sum_s \mathcal{R}\!\left((I\otimes\Pi_s)\rho_k^{\mathrm{pre}}(I\otimes\Pi_s)\right),
& m=\text{decoded},
\end{cases}
\]
를 \(k=0,\dots,T-1\)까지 반복한다.

그 뒤
\[
\text{state 경로: }F_{\mathrm{state}}=\langle00|\mathrm{Tr}_2[\rho_T]|00\rangle,
\]
\[
\text{decoded 경로: }P_{\mathrm{succ}} \text{ (위 식)}.
\]
S3는 회로 재귀는 S2\_log와 같고,
마지막 디코더 \(\hat{c}\)만 flat 대신 block consensus로 바뀐다.

\end{document}
